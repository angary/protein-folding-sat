% bule2 --solve --models 0 constraints.bul models/

% Generate the grid from the width
width[W]:: #ground coordinate[0..W - 1].
coordinate[I], coordinate[J]:: #ground grid[c(I, J)].

% Generate adjacent points
coordinate[I], coordinate[I + 1]:: #ground nextCoordinate[I, I + 1]. % Having coordinate[I + 1] ensures that I is less than width, so that nextCoordinate[I, I + 1] has (I, I + 1) as valid coordinates
coordinate[I], coordinate[I - 1]:: #ground nextCoordinate[I, I - 1]. % Having coordinate[I - 1] ensures same thing as above
coordinate[I], nextCoordinate[J, K]:: #ground adjacent[c(I, J), c(I, K)].
coordinate[I], nextCoordinate[J, K]:: #ground adjacent[c(J, I), c(K, I)].

% Ensuring Legal Embeddings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If x(i, j) is true, then the character at position i in the sequence is 
% assigned to point j in the grid
sequence[I, B], grid[G]:: #exists[0] x(I, G).
sequence[I, B], grid[G]:: #hide ~x(I, G).

% Every character in the sequence is assigned to some point in G
sequence[I, B]:: grid[G]: x(I, G).

% No character-position in the sequence can be assigned to more than one point
sequence[I, B], grid[G1], grid[G2], G1 != G2:: ~x(I, G1) | ~x(I, G2).

% No point in the grid can have more than one character-position assigned to it
grid[G], sequence[I1, B1], sequence[I2, B2], I1 != I2:: ~x(I1, G) | ~x(I2, G).

% Every adjacent pair of character positions must be placed on adjacent points in the grid
sequence[I, B1], sequence[I + 1, B2], grid[G1]:: ~x(I, G1) | grid[G2], adjacent[G1, G2]: x(I + 1, G2).

% Identifying Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grid[G]:: #exists[0] isOne(G).
grid[G]:: #hide ~isOne(G).

% A G, A I, (x(I, G) and sequence(I, 1)) -> T(G)
% A G, A I, (x(I, G) and sequence(I, 0)) -> ~T(G)
% A G, A I, ~x(I, G) -> ~T(G)

% -> can only be used for clauses, where hypothesis is conjunciton and conclusion is disjunction
grid[G], sequence[I, 1]:: x(I, G) -> isOne(G).
grid[G], sequence[I, 0]:: x(I, G) -> ~isOne(G).
grid[G]:: sequence[I, B]: x(I, G) | ~isOne(G). % For all I, G if x(I, G) is false -> t(G) has to be true

% c(G1, G2) is true iff "1" is assigned to t(G1) and t(G2)
adjacent[G1, G2]:: #exists[0] var(contact(G1, G2)).
adjacent[G1, G2]:: #hide ~var(contact(G1, G2)).

% If two adjacent points are "1" then there is a contact
adjacent[G1, G2]:: ~var(contact(G1, G2)) | isOne(G1).
adjacent[G1, G2]:: ~var(contact(G1, G2)) | isOne(G2).
adjacent[G1, G2]:: var(contact(G1, G2)) | ~isOne(G1) | ~isOne(G2).

% Counting Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Input:  `cardinality_var[V,X]` and `cardinality_bound[V,C]` where `V` is a name, `X` is a variable occuring in the cardinality constraint, and `C` is the bound.

% if r of x then cardinality bound of (0, x)
% we want to count the number of ~countact(G1, G2)

% r = Dimension * |G| - (goal contacts)
% goal contacts = dimemsion * |G| - r
% r[C], width[W]:: #ground goal[2 * W * W - C].

% We are going to count contact(G1, G2) for every adjacent
% Total number of contacts should be C
adjacent[G1, G2]:: #ground cardinality_var[0, contact(G1, G2)].
goal[C]:: #ground cardinality_bound[0, C].


% Add a filter / extra constraint
% Total number of contracts involve c(0, 0) on LHS should be 0
% adjacent[c(0, 0), G2]:: #ground cardinality_var[stuff, contact(c(0, 0), G2)].
% #ground cardinality_bound[stuff, 2].

% goal[C]:: #exists[0] g(C), debug.
% goal[C]:: g(C) | debug.
