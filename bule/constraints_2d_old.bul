% bule2 --solve --models 0 constraints.bul models/

% Generate the grid from the width
width[W] :: #ground coordinate[0 .. W - 1].
coordinate[I], coordinate[J] :: #ground grid[c(I, J)].

% Generate adjacent points
coordinate[I], coordinate[I + 1] :: #ground nextCoordinate[I, I + 1]. % Having coordinate[I + 1] ensures that I is less than width, so that nextCoordinate[I, I + 1] has (I, I + 1) as valid coordinates
% coordinate[I], coordinate[I - 1] :: #ground nextCoordinate[I, I - 1]. % Having coordinate[I - 1] ensures same thing as above
coordinate[I], nextCoordinate[J, K] :: #ground adjacent[c(I, J), c(I, K)].
coordinate[I], nextCoordinate[J, K] :: #ground adjacent[c(J, I), c(K, I)].

% Ensuring Legal Embeddings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If x(i, j) is true, then the character at position i in the sequence is 
% assigned to point j in the grid
sequence[I, B], grid[G] :: #exists[0] x(I, G).
sequence[I, B], grid[G] :: #hide ~x(I, G).

% Every character in the sequence is assigned to some point in G
sequence[I, B] :: grid[G] : x(I, G).

% No character-position in the sequence can be assigned to more than one point
sequence[I, B], grid[G1], grid[G2], G1 < G2:: ~x(I, G1) | ~x(I, G2).
% sequence[I, B], coordinate[X1], coordinate[Y1], coordinate[X2], coordinate[Y2], width[W], X1 * W + Y1 < X2 * W + Y2:: ~x(I, c(X1, Y1)) | ~x(I, c(X2, Y2)).

% No point in the grid can have more than one character-position assigned to it
grid[G], sequence[I1, B1], sequence[I2, B2], I1 < I2:: ~x(I1, G) | ~x(I2, G).

% Every adjacent pair of character positions must be placed on adjacent points in the grid
% sequence[I, B1], sequence[I + 1, B2], grid[G1] :: ~x(I, G1) | adjacent[G1, G2] : x(I + 1, G2). % This works when adjacent counts everything around it
sequence[I, B1], sequence[I + 1, B2], grid[G1] :: ~x(I, G1) | adjacent[G1, G2] : x(I + 1, G2) | adjacent[G3, G1] : x(I + 1, G3).

% % Identifying Potential Contacts
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% grid[G] :: #exists[0] isOne(G).
% grid[G] :: #hide ~isOne(G).

% % -> can only be used for clauses, where hypothesis is conjunciton and conclusion is disjunction
% grid[G], sequence[I, 1] :: ~x(I, G) | isOne(G).
% grid[G] :: sequence[I, 1] : x(I, G) | ~isOne(G).
% % grid[G], sequence[I, 0] :: x(I, G) -> ~isOne(G).
% % grid[G] :: sequence[I, B] : x(I, G) | ~isOne(G). % For all I, G if x(I, G) is false -> t(G) has to be false

% % c(G1, G2) is true iff "1" is assigned to t(G1) and t(G2)
% adjacent[G1, G2] :: #exists[0] var(contact(G1, G2)).
% adjacent[G1, G2] :: #hide ~var(contact(G1, G2)).

% % If two adjacent points are "1" then there is a contact
% adjacent[G1, G2] :: ~var(contact(G1, G2)) | isOne(G1) .
% adjacent[G1, G2] :: ~var(contact(G1, G2)) | isOne(G2).
% adjacent[G1, G2] :: var(contact(G1, G2)) | ~isOne(G1) | ~isOne(G2).

% % Counting Potential Contacts
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % We are going to count contact(G1, G2) for every adjacent
% % Total number of contacts should be C
% adjacent[G1, G2] :: #ground cardinality_var[0, contact(G1, G2)].
% goal[C] :: #ground cardinality_bound[0, C].
