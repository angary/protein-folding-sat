% adders
%%% Input: `fullAdder[I1,I2,I3,O1,O2]`
%%% Output: clauses constraining `var(I1)+var(I2)+var(I3)=2*var(O2)+var(O1)`
%%% Input: `halfAdder[X1,X2,Y1,Y2]`
%%% Output: clauses constraining `var(X1)+var(X2)=2*var(Y2)+var(Y1)`

#ground bit[0], bit[1].
bit[X], bit[Y], bit[Z] :: #ground parity3[X,Y,Z,(X+Y+Z) #mod 2].
bit[X], bit[Y], bit[Z], X+Y+Z >= 2 :: #ground large3[X,Y,Z,1].
bit[X], bit[Y], bit[Z], X+Y+Z <  2 :: #ground large3[X,Y,Z,0].

fullAdder[Y1,Y2,Y3,Z0,Z1], parity3[A,B,C,D] ::
    A==0:~var(Y1) & A==1:var(Y1) &
    B==0:~var(Y2) & B==1:var(Y2) &
    C==0:~var(Y3) & C==1:var(Y3)
 -> D==0:~var(Z0) | D==1:var(Z0).

fullAdder[Y1,Y2,Y3,Z0,Z1], large3[A,B,C,1], parity3[A,B,C,0] :: A==1: var(Y1) & B==1: var(Y2) & C==1: var(Y3) ->  var(Z1).
fullAdder[Y1,Y2,Y3,Z0,Z1], large3[A,B,C,0], parity3[A,B,C,1] :: A==0:~var(Y1) & B==0:~var(Y2) & C==0:~var(Y3) -> ~var(Z1).

halfAdder[Y1,Y2,Z0,Z1], parity3[A,B,0,D] :: A==0:~var(Y1) & A==1:var(Y1) & B==0:~var(Y2) & B==1:var(Y2) -> D==0:~var(Z0) | D==1:var(Z0).

halfAdder[Y1,Y2,Z0,Z1], large3[A,B,0,1], parity3[A,B,0,0] :: A==1: var(Y1) & B==1: var(Y2) ->  var(Z1).
halfAdder[Y1,Y2,Z0,Z1], large3[A,B,0,0], parity3[A,B,0,1] :: A==0:~var(Y1) & B==0:~var(Y2) -> ~var(Z1).

% cc_adder
%%% Input:  `cardinality_var[V,X]` and `cardinality_bound[V,C]` where `V` is a name, `X` is a variable occuring in the cardinality constraint, and `C` is the bound.
%%% Output: clauses constraining  `var(X1)+var(X2)+... = C`.

cardinality_var[V,X] :: #ground cca[V], set[V,X].

cca_equal[X,Y] :: var(X) -> var(Y).
cca_equal[X,Y] :: var(X) <- var(Y).

cca_aux[V,I,K], K > 0 :: #ground cca_aux[V,I,K-1].
cca_aux[V,I,K], K > 0 :: #ground cca_aux[V,I+2**(K-1),K-1].
cca_aux[V,I,K], K > 0,      order[V,X,I+2**(K-1)-1] :: #ground cca_equal[X, cca(V,c,I,K)].
cca_aux[V,I,K], K > 0, ~order_range[V,I+2**(K-1)-1] :: ~var(cca(V,c,I,K)).
cca_aux[V,I,K], K > 0 :: #ground cca_equal[cca(V,z,I+K-1,K), cca(V,c,I+K-1,K)].
cca_aux[V,I,K], K > 0, order_range[V,J], 0 <= J <= K-2 :: #ground fullAdder[cca(V,c,I+J,K),
                                                                            cca(V,z,I+J,K-1),
                                                                            cca(V,z,I+2**(K-1)+J,K-1),
                                                                            cca(V,z,I+J,K),
                                                                            cca(V,c,I+1+J,K)].



cardinality_bound[V,C] :: #ground logEnc[cca(V),C]. %logEnc[V,C, 1 + 2//(max C N)].

cca[V], order_last[V,N] :: #ground cca_start[V,1+2//(N+1)].
cca_start[V,K] :: #ground cca_aux[V,0,K].

cca_aux[V,I,K], K > 0, order_range[V,J], 0 <= J <= K-1 :: #exists[0] var(cca(V,z,I+J,K)).
cca_aux[V,I,K], K > 0, order_range[V,J], 0 <= J <= K-1 :: #exists[0] var(cca(V,c,I+J,K)).
cca_aux[V,I,K], K > 0, order_range[V,J], 0 <= J <= K-1 :: #hide var(cca(V,z,I+J,K)).
cca_aux[V,I,K], K > 0, order_range[V,J], 0 <= J <= K-1 :: #hide var(cca(V,c,I+J,K)).

cca_start[V,K], order_range[V,I], I <= K-1,  bitSet[cca(V),I] ::  var(cca(V,z,I,K)).
cca_start[V,K], order_range[V,I], I <= K-1, ~bitSet[cca(V),I] :: ~var(cca(V,z,I,K)).

% log_leq
%%% Input:  `logEnc[V,N]` where `V` is a name and `N` is an integer to be encoded in binary.
%%% Output: `bitSet[V,I]` indicates that in the binary encoding of `N` bit position `I` is set.

logEnc[V,N] :: #ground getLogAux[V,N,0].
getLogAux[V,N,I], N > 1 :: #ground getLogAux[V,N/2,I+1].
getLogAux[V,N,I], N #mod 2 == 1 :: #ground bitSet[V,I].

% order
%%% Input: `set[V,X]` a set `V` containing elements `X`.
%%% Output: `order[V,X,I]` `X` is the `I`th element in set `V` (the first element is numbered `0`th).
%%% Output: `order_last[V,N]` there are `N+1` elements in set `V`.
%%% Output: `order_range[V,I]` there is an element numbered `I` in set `V`.

set[V,X], set[V,Y], Y<X :: #ground order_has_prec[V,X].
set[V,X], ~order_has_prec[V,X] :: #ground order[V,X,0].
set[V,X], set[V,Y], X<Y, set[V,Z], Y<Z :: #ground order_are_split[V,X,Z].
set[V,X], set[V,Y], X<Y, ~order_are_split[V,X,Y], order[V,X,I] :: #ground order[V,Y,I+1].
set[V,X], set[V,Y], X<Y :: #ground order_has_succ[V,X].
set[V,X], ~order_has_succ[V,X], order[V,X,N] :: #ground order_last[V,N].
order[V,X,I] :: #ground order_range[V,I].
