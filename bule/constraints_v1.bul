% Dimension Encoding


% Parameter for enforcing if diferent in one dimension,same in others,comment to disable
#ground enforce_same[0].

% Generate the grid from the width
width[W] :: #ground pos[0 .. W - 1].

% Ensuring Legal Embeddings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If x(i,j) is true,then the character at position i in the sequence is 
% assigned to point j in the grid
sequence[I,B], pos[P], dim[D] :: #exists[0] x(I,P,D).

% Every character in the sequence is assigned to some point in a dimension
sequence[I,B], dim[D] :: pos[P] : x(I,P,D).  % TODO: Have new encoding for at least in position P (order encoding)

% No character-position in the sequence can be assigned to more than one point
sequence[I,B], dim[D], pos[P], pos[Q], P < Q :: ~x(I,P,D) | ~x(I,Q,D).

% No point in the grid can have more than one character-position assigned to it AKA two sequences cannot be on the same point
sequence[I,B], sequence[J,C], I < J :: #ground diff[I,J]. 
diff[I,J], dim[D] :: #exists[0] same(I,J,D).
diff[I,J], dim[D], pos[P] ::  x(I,P,D) &  x(J,P,D) ->  same(I,J,D).
diff[I,J], dim[D], pos[P] :: ~x(I,P,D) &  x(J,P,D) -> ~same(I,J,D).
diff[I,J], dim[D], pos[P] ::  x(I,P,D) & ~x(J,P,D) -> ~same(I,J,D).
diff[I,J] :: dim[D] : ~same(I,J,D).

% Every adjacent pair of character positions must be placed on adjacent points in the grid
sequence[I,1], sequence[J,1], J - I #mod 2 == 1,I+2 < J :: #ground pc[I,J].
sequence[I,B], sequence[I+1,C] :: #ground adj[I,I+1].
pc[I,J] :: #ground adj_or_pc[I,J].
adj[I,J] :: #ground adj_or_pc[I,J].
adj_or_pc[I,J], dim[D] :: #exists[0] next(I,J,D).

% If I and J are adjacent in one dir and not the others,they are next to each other
adj_or_pc[I,J], dim[D], pos[P], pos[P+1] :: x(I,P,D) & x(J,P+1,D) -> next(I,J,D). % J next to I on the larger side of the dimension
adj_or_pc[I,J], dim[D], pos[P], pos[P - 1] :: x(I,P,D) & x(J,P - 1,D) -> next(I,J,D). % J next to I on the smaller side of the dimension
adj_or_pc[I,J], dim[D], pos[P] ::  x(I,P,D) & pos[P+1] : ~x(J,P+1,D) & pos[P - 1] : ~x(J,P - 1,D) -> ~next(I,J,D). % Not next if J is not 1 up and 1 down from I

adj[I,J] :: dim[D] : next(I,J,D). % I and I+1 has to be different in at least one dimension
enforce_same[0], adj[I,J], dim[D1], dim[D2], D1 != D2 :: next(I,J,D1) -> same(I,J,D2). % If different in one dimension,it has to be same in the others 
adj[I,J], dim[D] :: same(I,J,D) -> ~next(I,J,D). % Cannot be same and next in the same dimension

% Identifying Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% f I and J are next to each other then there is a contact
pc[I,J] :: #exists[0] var(contact(I,J)).
% Only condition for contact if Next in D1 and same in D2
pc[I,J], dim[D1] ::  next(I,J,D1) & dim[D2], D1 != D2 :  same(I,J,D2) ->  var(contact(I,J)).
pc[I,J], dim[D1] :: ~next(I,J,D1) & dim[D2], D1 != D2 :  same(I,J,D2) -> ~var(contact(I,J)).
pc[I,J], dim[D1] :: ~next(I,J,D1) & dim[D2], D1 != D2 : ~next(I,J,D2) -> ~var(contact(I,J)).
pc[I,J], dim[D1], dim[D2], D1 != D2 ::  next(I,J,D1) & ~same(I,J,D2) -> ~var(contact(I,J)).

% Counting Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#ground accumulate[0,0].

sequence[I,0], sequence[I+1,0], accumulate[I,J] :: #ground accumulate[I+1,J].
sequence[I,0], sequence[I+1,1], accumulate[I,J] :: #ground accumulate[I+1,J].
sequence[I,1], sequence[I+1,0], accumulate[I,J] :: #ground accumulate[I+1,J].
sequence[I,1], sequence[I+1,1], accumulate[I,J] :: #ground accumulate[I+1,J+1].

% Want to determine how many adjacent ones there are
accumulate[I,J], ~sequence[I+1,0], ~sequence[I+1,1] :: #ground base_contacts[J].

% Total number of contacts should be C
pc[I,J] :: #ground cardinality_var[0,contact(I,J)].
goal[C], base_contacts[B] :: #ground cardinality_bound[0,C - B].
