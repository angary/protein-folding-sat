% Order Encoding

#ground enforce_same[0].

% Generate the grid from the width
width[W] :: #ground pos[0..W-1].

% Ensuring Legal Embeddings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If y(I,P,D) is true,then the character at position i in the sequence is 
% at least in position P in dimension D
sequence[I,_], pos[P], dim[D] :: #exists[0] y(I,P,D).

% Every character in the sequence is assigned to some point in a dimension (at least in position 0)
sequence[I,_], dim[D] :: y(I,0,D).

% No character-position in the sequence can be assigned to more than one point
sequence[I,_], dim[D], pos[P], pos[P+1], P>0 :: y(I,P+1,D) -> y(I,P,D).

% No point in the grid can have more than one character-position assigned to it AKA two indexes cannot be on the same point
sequence[I,_], sequence[J,_], I<J :: #ground diff[I,J]. 
diff[I,J], dim[D] :: #exists[0] same(I,J,D).
diff[I,J], dim[D], pos[P] ::  pos[P+1] : ~y(I,P+1,D) & y(I,P,D) & pos[P+1] : ~y(J,P+1,D) & y(J,P,D) ->  same(I,J,D).
diff[I,J], dim[D], pos[P], P>0 :: ~y(I,P,D) &  y(J,P,D) -> ~same(I,J,D).
diff[I,J], dim[D], pos[P], P>0 ::  y(I,P,D) & ~y(J,P,D) -> ~same(I,J,D).
diff[I,J] :: dim[D] : ~same(I,J,D).

% Every adjacent pair of character positions must be placed on adjacent points in the grid
sequence[I,1], sequence[J,1], J-I #mod 2 == 1, I+2 < J :: #ground pc[I,J].
sequence[I,_], sequence[I+1,_] :: #ground adj[I,I+1].
pc[I,J] :: #ground adj_or_pc[I,J].
adj[I,J] :: #ground adj_or_pc[I,J].
adj_or_pc[I,J], dim[D] :: #exists[0] next(I,J,D).

% If I and J are adjacent in one dir and not the others,they are next to each other
adj_or_pc[I,J], dim[D], pos[P], pos[P+1] :: ~y(I,P+1,D) & y(I,P,D) & pos[P+2] : ~y(J,P+2,D) & y(J,P+1,D) -> next(I,J,D). 
adj_or_pc[I,J], dim[D], pos[P], pos[P+1] :: pos[P+2] : ~y(I,P+2,D) & y(I,P+1,D) & ~y(J,P+1,D) & y(J,P,D) -> next(I,J,D).
adj_or_pc[I,J], dim[D], pos[P], pos[P+1], P>0 ::  y(I,P+1,D) & ~y(J,P,D) -> ~next(I,J,D).
adj_or_pc[I,J], dim[D], pos[P], pos[P+1], P>0 :: ~y(I,P,D) &  y(J,P+1,D) -> ~next(I,J,D).

adj[I,J] :: dim[D] : next(I,J,D). % I and I+1 has to be different in at least one dimension
enforce_same[0], adj[I,J], dim[D1], dim[D2], D1 != D2 :: next(I,J,D1) -> same(I,J,D2). % If different in one dimension,it has to be same in the others 
adj[I,J], dim[D] :: same(I,J,D) -> ~next(I,J,D). % Cannot be same and next in the same dimension

% Identifying Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% f I and J are next to each other then there is a contact
pc[I,J] :: #exists[0] var(contact(I,J)).
% Only condition for contact if Next in D1 and same in D2
pc[I,J], dim[D1] ::  next(I,J,D1) & dim[D2], D1 != D2 :  same(I,J,D2) ->  var(contact(I,J)).
pc[I,J], dim[D1] :: ~next(I,J,D1) & dim[D2], D1 != D2 :  same(I,J,D2) -> ~var(contact(I,J)).
pc[I,J], dim[D1] :: ~next(I,J,D1) & dim[D2], D1 != D2 : ~next(I,J,D2) -> ~var(contact(I,J)).
pc[I,J], dim[D1], dim[D2], D1 != D2 ::  next(I,J,D1) & ~same(I,J,D2) -> ~var(contact(I,J)).

% Counting Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#ground accumulate[0,0].

sequence[I,0], sequence[I+1,0], accumulate[I,J] :: #ground accumulate[I+1,J].
sequence[I,0], sequence[I+1,1], accumulate[I,J] :: #ground accumulate[I+1,J].
sequence[I,1], sequence[I+1,0], accumulate[I,J] :: #ground accumulate[I+1,J].
sequence[I,1], sequence[I+1,1], accumulate[I,J] :: #ground accumulate[I+1,J+1].

% Want to determine how many adjacent ones there are
accumulate[I,J], ~sequence[I+1,0], ~sequence[I+1,1] :: #ground base_contacts[J].

% Total number of contacts should be C
pc[I,J] :: #ground cardinality_var[0,contact(I,J)].
goal[C], base_contacts[B] :: #ground cardinality_bound[0,C - B].
