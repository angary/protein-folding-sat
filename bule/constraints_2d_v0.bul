% Original Encoding (2D)

% Generate the grid from the width
width[W] :: #ground coordinate[0 .. W - 1].
coordinate[I], coordinate[J] :: #ground grid[c(I,J)].

% Generate adjacent points
coordinate[I], coordinate[I+ 1] :: #ground next_coordinate[I,I+ 1].
coordinate[I], next_coordinate[J,K] :: #ground adj[c(I,J),c(I,K)].
coordinate[I], next_coordinate[J,K] :: #ground adj[c(J,I),c(K,I)].

% Ensuring Legal Embeddings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If x(i,j) is true,then the character at position i in the sequence is 
% assigned to point j in the grid
sequence[I,B], grid[G] :: #exists[0] x(I,G).
sequence[I,B], grid[G] :: #hide ~x(I,G).

% Every character in the sequence is assigned to some point in G
sequence[I,B] :: grid[G] : x(I,G).

% No character-position in the sequence can be assigned to more than one point
sequence[I,B], grid[G1], grid[G2], G1 < G2 :: ~x(I,G1) | ~x(I,G2).

% No point in the grid can have more than one character-position assigned to it
grid[G], sequence[I1,B1], sequence[I2,B2], I1 < I2 :: ~x(I1,G) | ~x(I2,G).

% Every adjacent pair of character positions must be placed on adjacent points in the grid
sequence[I,B1], sequence[I+ 1,B2], grid[G1] :: ~x(I,G1) | adj[G1,G2] : x(I+ 1,G2) | adj[G3,G1] : x(I+ 1,G3).

% Identifying Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grid[G] :: #exists[0] is_one(G).
grid[G] :: #hide ~is_one(G).

% -> can only be used for clauses, where hypothesis is conjunction and conclusion is disjunction
grid[G], sequence[I,1] :: ~x(I,G) | is_one(G).
grid[G] :: sequence[I,1] : x(I,G) | ~is_one(G).

% c(G1,G2) is true iff "1" is assigned to t(G1) and t(G2)
adj[G1,G2] :: #exists[0] var(contact(G1,G2)).
adj[G1,G2] :: #hide ~var(contact(G1,G2)).

% If two adjacent points are "1" then there is a contact
adj[G1,G2] :: ~var(contact(G1,G2)) | is_one(G1).
adj[G1,G2] :: ~var(contact(G1,G2)) | is_one(G2).
adj[G1,G2] :: var(contact(G1,G2)) | ~is_one(G1) | ~is_one(G2).

% Counting Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% We are going to count contact(G1,G2) for every adjacent
% Total number of contacts should be C
adj[G1,G2] :: #ground cardinality_var[0,contact(G1,G2)].
goal[C] :: #ground cardinality_bound[0,C].
