% Counter encoding for linear constraints

cardinality_var[ID,X] :: #ground counter_var[ID,X].
cardinality_bound[ID,C] :: #ground counter_bound[ID,geq,C].

% ID is the reference for the cardinality constraint to be encoded. Make sure it is unique across the program. 
% INPUT: counter_var[ID,X] - prerequisit: var(X) is a variable occuring in the constraint. 
% INPUT: counter_bound[ID,T,C] -  T is {eq,geq,leq} for ==, >=,<=  and C the bound. 
% OUTPUT: counter encoding for the cardinality constraint: X1+X2+X3 ... <T> C. 

counter_var[ID,X] :: #ground set[ID,X].  % import from oder.bul2: creates order, order_last and order_range

order_range[ID,I] :: #ground counter_I[ID,I].
order_range[ID,I] :: #ground counter_I[ID,I-1].

order_range[ID,J], counter_bound[ID,_,C], J <= C :: #ground counter_J[ID,J]. 
counter_bound[ID,_,C], C>0 :: #ground counter_J[ID,C]. 
counter_bound[ID,_,C], C>0 :: #ground counter_J[ID,C+1]. 
 
counter_I[ID,I], counter_J[ID,J], I>=J-2, counter_bound[ID,_,C], order_last[ID,N], I-J <= N-C :: 
    #ground counter_IJ[ID,I,J].

counter_IJ[ID,I,J] :: #exists[0] count(ID,I,J).
  
%TODO: remove redundant clauses if geq or leq only

counter_IJ[ID,I,J], counter_IJ[ID,I+1,J]                    :: ~count(ID,I,J) | count(ID,I+1,J).
counter_IJ[ID,I,J], order[ID,X,I+1], counter_IJ[ID,I+1,J+1] :: ~var(X) | ~count(ID,I,J) | count(ID,I+1,J+1).

counter_IJ[ID,I,J], counter_IJ[ID,I+1,J+1]                  :: ~count(ID,I+1,J+1) | count(ID,I,J).
order[ID,X,I], counter_IJ[ID,I,J], counter_IJ[ID,I-1,J]     ::  var(X) | ~count(ID,I,J) | count(ID,I-1,J).

counter_bound[ID,_,_] ::  count(ID,-1,0). 
counter_bound[ID,_,_] :: ~count(ID,-1,1). 

counter_bound[ID,eq,C] :: #ground counter_bound[ID,geq,C],counter_bound[ID,leq,C].
counter_bound[ID,geq,C], order_last[ID,I] :: count(ID,I,C). 
counter_bound[ID,leq,C], order_last[ID,I] :: ~count(ID,I,C+1). 

%% fail if bound cannot be reached
counter_bound[ID,geq,C], order_last[ID,N], C>N+1 :: . 


%% ORDER

%%% Input: `set[V,X]` a set `V` containing elements `X`.
%%% Output: `order[V,X,I]` `X` is the `I`th element in set `V` (the first element is numbered `0`th).
%%% Output: `order_last[V,N]` there are `N+1` elements in set `V`.
%%% Output: `order_range[V,I]` there is an element numbered `I` in set `V`.

set[V,X], set[V,Y], Y<X :: #ground order_has_prec[V,X].
set[V,X], ~order_has_prec[V,X] :: #ground order[V,X,0].
set[V,X], set[V,Y], X<Y, set[V,Z], Y<Z :: #ground order_are_split[V,X,Z].
set[V,X], set[V,Y], X<Y, ~order_are_split[V,X,Y], order[V,X,I] :: #ground order[V,Y,I+1].
set[V,X], set[V,Y], X<Y :: #ground order_has_succ[V,X].
set[V,X], ~order_has_succ[V,X], order[V,X,N] :: #ground order_last[V,N].
order[V,X,I] :: #ground order_range[V,I].
