% bule2 --solve --models 0 constraints.bul models/

% Generate the grid from the width
width[W] :: #ground pos[0 .. W - 1].
#ground dim[0 .. 1].

% Ensuring Legal Embeddings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If x(i, j) is true, then the character at position i in the sequence is 
% assigned to point j in the grid
sequence[I, B], pos[P], dim[D] :: #exists[0] x(I, P, D).
sequence[I, B], pos[P], dim[D] :: #hide ~x(I, P, D).

% Every character in the sequence is assigned to some point in a dimension
sequence[I, B], dim[D] :: pos[P] : x(I, P, D).  % TODO: Have new encoding for at least in position P (order encoding)

% No character-position in the sequence can be assigned to more than one point
sequence[I, B], dim[D], pos[P], pos[Q], P < Q :: ~x(I, P, D) | ~x(I, Q, D).

% No point in the grid can have more than one character-position assigned to it AKA two sequences cannot be on the same point
sequence[I, B], sequence[J, C], I < J :: #ground different[I, J]. 
different[I, J], dim[D] :: #exists[0] same(I, J, D).
different[I, J], dim[D] :: #hide same(I, J, D), ~same(I, J, D).
different[I, J], dim[D], pos[P] ::  x(I, P, D) &  x(J, P, D) ->  same(I, J, D).
different[I, J], dim[D], pos[P] :: ~x(I, P, D) &  x(J, P, D) -> ~same(I, J, D).
different[I, J], dim[D], pos[P] ::  x(I, P, D) & ~x(J, P, D) -> ~same(I, J, D).
different[I, J] :: dim[D] : ~same(I, J, D).

% Every adjacent pair of character positions must be placed on adjacent points in the grid
sequence[I, B], sequence[I + 1, C], dim[D] :: #ground adj[I, I + 1].
adj[I, J], dim[D] :: #exists[0] direction(I, J, D).
adj[I, J], dim[D] :: #hide direction(I, J, D),  ~direction(I, J, D).
adj[I, J], dim[D], pos[P],  pos[P + 1] ::  x(I, P, D) &  x(J, P + 1, D) ->  direction(I, J, D).
adj[I, J], dim[D], pos[P],  pos[P - 1] ::  x(I, P, D) &  x(J, P - 1, D) ->  direction(I, J, D).
adj[I, J], dim[D], pos[P],  pos[P + 1],  pos[P - 1] ::  x(I, P, D) & ~x(J, P + 1, D) & ~x(J, P - 1, D) -> ~direction(I, J, D).
adj[I, J], dim[D], pos[P],  pos[P + 1], ~pos[P - 1] ::  x(I, P, D) & ~x(J, P + 1, D) -> ~direction(I, J, D).
adj[I, J], dim[D], pos[P], ~pos[P + 1],  pos[P - 1] ::  x(I, P, D) & ~x(J, P - 1, D) -> ~direction(I, J, D).
adj[I, J] :: dim[D] : direction(I, J, D). % I and I + 1 has to be different in at least one dimension
adj[I, J], dim[D1], dim[D2], D1 != D2 :: direction(I, J, D1) -> same(I, J, D2). % If it is different in one dimension, it has to be same in the others
adj[I, J], dim[D] :: same(I, I + 1, D) -> ~direction(I, J, D). % If it is the same in one dimension, it cannot be direction in the same dimension
% Can also have a `direction(sequenceI, polarityP, dimensionD)`

% Identifying Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sequence[I, 1], sequence[J, 1], I + 1 < J :: #ground nonAdjOne[I, J].
sequence[I, 1], sequence[J, 1], I + 1 < J, dim[D] :: #exists[0] next(I, J, D).
sequence[I, 1], sequence[J, 1], I + 1 < J, dim[D] :: #hide next(I, J, D), ~next(I, J, D).

% If I and J are adjacent in one dir and not the others, they are next to each other
nonAdjOne[I, J], dim[D], pos[P], pos[P + 1] :: x(I, P, D) & x(J, P + 1, D) -> next(I, J, D).
nonAdjOne[I, J], dim[D], pos[P], pos[P - 1] :: x(I, P, D) & x(J, P - 1, D) -> next(I, J, D).
nonAdjOne[I, J], dim[D], pos[P],  pos[P + 1],  pos[P - 1] ::  x(I, P, D) & ~x(J, P + 1, D) & ~x(J, P - 1, D) -> ~next(I, J, D).
nonAdjOne[I, J], dim[D], pos[P],  pos[P + 1], ~pos[P - 1] ::  x(I, P, D) & ~x(J, P + 1, D) -> ~next(I, J, D).
nonAdjOne[I, J], dim[D], pos[P], ~pos[P + 1],  pos[P - 1] ::  x(I, P, D) & ~x(J, P - 1, D) -> ~next(I, J, D).

% % If I and J are next to each other then there is a contact
sequence[I, 1], sequence[J, 1], I + 1 < J :: #exists[0] var(contact(I, J)).
sequence[I, 1], sequence[J, 1], I + 1 < J :: #hide ~var(contact(I, J)).
% Only condition for contact if Next in D1 and same in D2
nonAdjOne[I, J], dim[D1] ::  next(I, J, D1) & dim[D2], D1 != D2 : same(I, J, D2) ->  var(contact(I, J)).
nonAdjOne[I, J], dim[D1] :: ~next(I, J, D1) & dim[D2], D1 != D2 : same(I, J, D2) -> ~var(contact(I, J)).
nonAdjOne[I, J], dim[D1] :: ~next(I, J, D1) & dim[D2], D1 != D2 : ~next(I, J, D2) -> ~var(contact(I, J)).
nonAdjOne[I, J], dim[D1], dim[D2], D1 != D2 :: next(I, J, D1) & ~same(I, J, D2) -> ~var(contact(I, J)).

% Counting Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Total number of contacts should be C
sequence[I, 1], sequence[J, 1], I + 1 < J :: #ground cardinality_var[0, contact(I, J)].
goal[C] :: #ground cardinality_bound[0, C].
